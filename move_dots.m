function [xy,coherence_frame,mean_coherence,pre_incoh_mo_coh,blocks_shuffled] = ...
    move_dots(discrete_trials,trial,total_frames,ap_radius,...
    coherence_sd,direction_org,step,Nd,pre_incoh_mo,...
    mean_coherence,blocks_coherence_cells,coherence_frame,...
    coherence_list,ITIS_vec,integration_long,noise,passbandfreq,...
    stopbandfreq,passrip,stopbandatten,framerate,noise_amplitude,mean_duration,sd_duration,noise_function,stim_function)

% This function creates dot positios of rdks for discrete trials or continuous blocks of
% motion and saves x and y coordinates of dots for each frame, the stimulus
% is coded in a way that there are 3 sets of dots and every dot is
% displayed only every third frame

% Input:

% discrete_trials   - flag 1 if discrete trials displayed for training, 0
%                     if continuous version
% trial             - current trial ID only for discrete trial version
% total_frames      - number of frames random dots are displayed - this is
%                     for pre-allocation of space
% ap_radius         - radius of the circular aperture in which the dots are
%                     displayed
% coherence_sd      - standard deviation for a normal distributin that we
%                     use to sample coherence levels during incoherent motion
%                     periods
% direction_org     - used to calculate in which direction the dots are
%                     moving - just a 1 - has been used for something else
%                     in the past
% step              - speed with which the signal dots move - pixes/frame
% Nd                - number of dots displayed per frame
% pre_incoh_m       - time incoherent motion is displayed before coherent
%                     motion starts in discrete trial version (in number of frames)
% mean_coherence    - pre-allocated vector which will be a vector out of
%                     zeros for incoherent motion periods and the level of
%                     coherence at periods of coherent motion for each frame
%                     (for continuous task version only)
% blocks_coherence
% _cells            - vector with sequence coherence values used for
%                     coherent motion periods - used to fill up coherent
%                     periods in mean_coherence (for continuous task
%                     version only)
% coherence_frame   - pre-allocated vector that gets assigned coherence
%                     values during incoherent and coherent motion periods
%                     for each frame
% coherence_list    - list of coherences for trials (discrete trial version
%                     only) (basically same as blocks_coherence_cells for
%                     continuous motion task)
% ITIS_vec          - vector containing list of length of incoherent motion
%                     periods between coherent motion periods in number of
%                     frames (only continuous motion task)
% integration_long  - length of a coherent motion period in number of
%                     frames (continuous motion task only)
% noise             - flag 0: when calculating the original coherence_frame
%                     vector for displaying the rdms, however, every time
%                     button has been pressed during coherent motion period,
%                     the remaining frames of coherent motion have to be
%                     replaced by incoherent motion which is drawn from
%                     another vector that is generated when the flag = 1
%                     (continuous motion task only)
% passbandfreq      - passbandfreq for lowpass filtering
%                     fluctuations of coherences during incoherent motion
%                     periods (continuous motion task only)
% stopbandfreq      - stopandfrequencey for low pass filtering incoherent
%                     motion periods (continuous motion task only)
% passrip           - passrip for low pass filtering incoherent
%                     motion periods (continuous motion task only)
% stopbandatten     - stopandattenuation for low pass filtering incoherent
%                     motion periods (continuous motion task only)
% framerate         - sampling rate (= screen frame rate)
%                     for low pass filtering incoherent motion periods
%                     (continuous motion task only)
% nosie_amplitude   - scalar scaling the low pass filtered incoherent
%                     motion coherences (continuous motion task only)
% mean_duration     - in case incoherent motion periods are generated by
%                     drawing steps from an exponential function when
%                     coherence values change, this is the mean duration
%                     before a step occurs
%
%


% Output:
% xy                - 2xNdxf matrix, where first row is x position and,
%                     second row is y position for number of (Nd) dots for
%                     each frame (f)
% coherence_frame   - vector with coherence
%                     values during incoherent and coherent motion periods
%                     for each frame
% mean_coherence    - vector of zeros for incoherent motion periods and the level of
%                     coherence at periods of coherent motion for each frame
%                     (for continuous task version only)
% pre_incoh_mo_coh  - vector with incoherent motion frames for incoherent
%                     motion periods before coherent motion periods during
%                     discrete trials

% Maria Ruesseler, University of Oxford, 2018

%
% here we pre-allocate frames 
pre_incoh_mo_coh = [];

if discrete_trials == 1 
    blocks_shuffled = [];
    xy = zeros(2,Nd,total_frames);
    
    % pre_allocate frames for incoh motion before actual stim starts
    
    pre_incoh_mo_coh = zeros(pre_incoh_mo,1);
    
    
    for i = 1:3 % random dot location for first frame of each dot set
        xy(:,:,i) = xypos(Nd, ap_radius);
    end
    

elseif discrete_trials == 2 
     blocks_shuffled = [];
        xy = zeros(2,Nd,total_frames);
    
    % pre_allocate frames for incoh motion before actual stim starts
    
    pre_incoh_mo_coh = zeros(pre_incoh_mo,1);
    
    
    for i = 1:3 % random dot location for first frame of each dot set
        xy(:,:,i) = xypos(Nd, ap_radius);
    end
    

    
        [disc_coherence_vec] = calculate_coherence_vec(total_frames,sd_duration(2),mean_duration(2),coherence_sd(2),coherence_list(trial),[], [], stim_function); 
     [disc_incoherence_vec] = calculate_coherence_vec(pre_incoh_mo,sd_duration(1),mean_duration(1),coherence_sd(1),0,[], [], stim_function); 
     
     discrete_trial_vec = [disc_incoherence_vec; disc_coherence_vec ];
     
     
else % continuous rdk
    xy = zeros(2,Nd,total_frames);
end % diskreite trials

idx = 1; % index to loop through incoherent  motion periods (first frame of incoherent motion period)
tr = 1;  % index to loop through coherent motion periods

% design filter to lowpass filter noise % sample rate is screen refresh
% rate
ft = designfilt('lowpassfir', 'PassbandFrequency', passbandfreq, 'StopbandFrequency', stopbandfreq,...
    'PassbandRipple', passrip, 'StopbandAttenuation', stopbandatten, 'SampleRate', framerate);


% now we calculate dot positions first for conntinous trials 
if ~discrete_trials
    if noise == 0 % if we are not generating a noise vector for replacing coherence motion after button press
        
        
        
        for i = 1 : numel(ITIS_vec) % loop through incoherent motion periods of a block
           
            
            
            
            incoh_filtered = calculate_coherence_vec(ITIS_vec(i),sd_duration(1),mean_duration(1),...
                coherence_sd(1),0,ft, noise_amplitude,...
                noise_function);
            
            
            
            
            
            
            
            % get idx of last frame of this period of incoherent motion
            end_of_incoh_mot = idx + ITIS_vec(i)-1;
            
            % set incoherent motion period in mean_coherence vector to a mean
            % coherence of 0
            mean_coherence(idx : end_of_incoh_mot)= zeros(ITIS_vec(i),1); % incoh_motion mean for ITIS interval
            blocks_shuffled(idx : end_of_incoh_mot)= zeros(ITIS_vec(i),1);
            % fill the same epoch with the filtered incoherent motion in the
            % coherencne_frame vector
            coherence_frame(idx:end_of_incoh_mot) = incoh_filtered;
            
            % calculate first idx of coherent motion period
            first_coh_mot_f = idx + ITIS_vec(i);
            
            % calculate last idx of coherent motion period
            % last_coh_mot_f = first_coh_mot_f + integration_long -1;
            
            if i < numel(ITIS_vec) % if we are not in last incoherent motion period
                % before block ends add coherent motion period onto last incoherent motion period
                
     
                
                
                
                
                mean_coh_vec = ...
                    calculate_coherence_vec(integration_long+1,sd_duration(2),mean_duration(2),coherence_sd(2),...
                    blocks_coherence_cells(tr),[], [], stim_function);
                
                
                
                last_coh_mot_f = first_coh_mot_f + length(mean_coh_vec) -1;
                
                %mean_coherence(first_coh_mot_f :last_coh_mot_f )= mean_coh_vec;
                coherence_frame(first_coh_mot_f:last_coh_mot_f)=       mean_coh_vec;
                mean_coherence(first_coh_mot_f :last_coh_mot_f )=      zeros(length(mean_coh_vec),1)+ blocks_coherence_cells(tr);
                blocks_shuffled(first_coh_mot_f :last_coh_mot_f )= zeros(length(mean_coh_vec),1) + tr; 
                %      coherence_frame(first_coh_mot_f:last_coh_mot_f)= blocks_coherence_cells(tr);
            end
            
            %
            %
            idx = last_coh_mot_f + 1; % update first frame of next incohrent motion period
            tr = tr + 1; % update trial for next coherent motion period
            
        end
        
        
        %
        
    else % if creating noise vector from which we draw frames when participant has pressed button
        
 
      
        
        
        noise_vec = calculate_coherence_vec(ITIS_vec(1),sd_duration(1),mean_duration(1),...
            coherence_sd(1),0,ft, noise_amplitude,...
            noise_function);
        
 
        mean_coherence = zeros(ITIS_vec(1),1);
        coherence_frame = noise_vec;
        
        total_frames = size(noise_vec,1); 
    end % if noise vector
    
end % if ~discrete trials



if discrete_trials >0 
    
    total_frames = total_frames + pre_incoh_mo; 
    
end 



for f = 1:total_frames % loop through all frames
    
    
    if discrete_trials == 1
        
        if f <= pre_incoh_mo % incoherent motion at start of trial with certain sd
            
            
            pre_incoh_mo_coh(f) = 0;
            coherence = pre_incoh_mo_coh(f);
        else % if incoherent phase over show coherent motion
            
            coherence = coherence_list(trial);
            
        end
        
        
    elseif discrete_trials == 2 
        
coherence = discrete_trial_vec(f); 

        
    else
        
        coherence = coherence_frame(f);
        
        
        
    end
    
    
    % if coherence negative change motion direction and turn coherence in
    % positive number
    if coherence < 0
        direction = -direction_org;
    else
        direction = direction_org;
    end
    
    
    
    
    %move dots - but first determine whether dots move in coherence
    %direction or randomly
    
    coh_prob = rand(1,Nd);
    
    %index vectors to noise and signal dots
    index_signal = find (coh_prob <= abs(coherence));
    index_noise = coh_prob > abs(coherence);
    
    %move noise dots
    
    xy(:,index_noise,f) = xypos(sum(index_noise), ap_radius);
    
    %move signal dots - but only if we are above 3 frames because every
    %set of dots is shown only on every 3rd frame, otherwise all dots move randomly
    if f > 3
        xy(1,index_signal,f) = xy(1,index_signal,f-3) + step * direction * 3;
        xy(2,index_signal,f) = xy(2,index_signal,f-3);
    else
        
        xy(:,index_signal,f) = xypos(numel(index_signal), ap_radius);
    end % if f > 3
    
    
    % check whether dot crossed apperture, if dot crossed aperture -
    % re-plot at random location on opposite side of moving direction
    %outside the aperture then move dot with a random distance back into
    %the aperture
    
    % calculate distance to aperture centre
    distance_x_centre = sqrt(xy(1,index_signal,f).^2 + xy(2,index_signal,f).^2 );
    
    % get signal dots that have a distance greater than the radius
    % meaning that they are outside the aperture
    idx_dist = index_signal(distance_x_centre >= ap_radius);
    
    if ~isempty(idx_dist) % if dots moved outside apperture
        %replex y and x coordinates of the dots to a place on the opposite
        %site of the aperture
        
        xy(2,idx_dist,f) = 2 .* ap_radius .* rand(size(idx_dist)) - ap_radius;
        xy(1,idx_dist,f) = sqrt((ap_radius^2) - (xy(2,idx_dist,f).^2) );
        
        %move signal dots back into aperture
        xy(1,idx_dist,f) = xy(1,idx_dist,f) - rand(size(idx_dist)) .* step;
        
        % needs to be mirrored if coherence is positive
        if direction > 0
            xy(1,idx_dist,f) = - xy(1,idx_dist,f);
        end
    end % if dots moved outside apperture
    
end % loop through frames



end % function

%% additional functions
%xypos function - find randomised x and y coordinates for dots, needs
%number of dots (n) and radius of aperture in pixels (r)

function [XY] = xypos(n, r)

%find angles

theta = 2*pi*rand(1,n);

% find radius

radius = r * sqrt(rand(1,n));

%radius = r * rand(1,n);

%back to cartesian coordinate system
XY = [radius.*cos(theta); radius.*sin(theta)];

end %xypos
